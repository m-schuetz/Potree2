{"version":3,"file":"radix-sort-esm.js","sources":["../../src/shaders/prefix_sum.js","../../src/shaders/optimizations/prefix_sum_no_bank_conflict.js","../../src/utils.js","../../src/PrefixSumKernel.js","../../src/shaders/radix_sort.js","../../src/shaders/optimizations/radix_sort_local_shuffle.js","../../src/shaders/radix_sort_reorder.js","../../src/shaders/check_sort.js","../../src/CheckSortKernel.js","../../src/RadixSortKernel.js"],"sourcesContent":["const prefixSumSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ITEMS_PER_WORKGROUP: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reduce_downsweep(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n    let ELM_TID = TID * 2; // Element pair local ID\r\n    let ELM_GID = GID * 2; // Element pair global ID\r\n    \r\n    // Load input to shared memory\r\n    temp[ELM_TID]     = select(items[ELM_GID], 0, ELM_GID >= ELEMENT_COUNT);\r\n    temp[ELM_TID + 1] = select(items[ELM_GID + 1], 0, ELM_GID + 1 >= ELEMENT_COUNT);\r\n\r\n    var offset: u32 = 1;\r\n\r\n    // Up-sweep (reduce) phase\r\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            temp[bi] += temp[ai];\r\n        }\r\n\r\n        offset *= 2;\r\n    }\r\n\r\n    // Save workgroup sum and clear last element\r\n    if (TID == 0) {\r\n        let last_offset = ITEMS_PER_WORKGROUP - 1;\r\n\r\n        blockSums[WORKGROUP_ID] = temp[last_offset];\r\n        temp[last_offset] = 0;\r\n    }\r\n\r\n    // Down-sweep phase\r\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\r\n        offset >>= 1;\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n\r\n            let t: u32 = temp[ai];\r\n            temp[ai] = temp[bi];\r\n            temp[bi] += t;\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Copy result from shared memory to global memory\r\n    if (ELM_GID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n    items[ELM_GID] = temp[ELM_TID];\r\n\r\n    if (ELM_GID + 1 >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n    items[ELM_GID + 1] = temp[ELM_TID + 1];\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn add_block_sums(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    let ELM_ID = GID * 2;\r\n\r\n    if (ELM_ID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    let blockSum = blockSums[WORKGROUP_ID];\r\n\r\n    items[ELM_ID] += blockSum;\r\n\r\n    if (ELM_ID + 1 >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    items[ELM_ID + 1] += blockSum;\r\n}`\r\n\r\nexport default prefixSumSource","/**\r\n * Prefix sum with optimization to avoid bank conflicts\r\n * \r\n * (see Implementation section in README for details)\r\n */\r\nconst prefixSumNoBankConflictSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> items: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ITEMS_PER_WORKGROUP: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nconst NUM_BANKS: u32 = 32;\r\nconst LOG_NUM_BANKS: u32 = 5;\r\n\r\nfn get_offset(offset: u32) -> u32 {\r\n    // return offset >> LOG_NUM_BANKS; // Conflict-free\r\n    return (offset >> NUM_BANKS) + (offset >> (2 * LOG_NUM_BANKS)); // Zero bank conflict\r\n}\r\n\r\nvar<workgroup> temp: array<u32, ITEMS_PER_WORKGROUP*2>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reduce_downsweep(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n    \r\n    let ELM_TID = TID * 2; // Element pair local ID\r\n    let ELM_GID = GID * 2; // Element pair global ID\r\n    \r\n    // Load input to shared memory\r\n    let ai: u32 = TID;\r\n    let bi: u32 = TID + (ITEMS_PER_WORKGROUP >> 1);\r\n    let s_ai = ai + get_offset(ai);\r\n    let s_bi = bi + get_offset(bi);\r\n    let g_ai = ai + WID * 2;\r\n    let g_bi = bi + WID * 2;\r\n    temp[s_ai] = select(items[g_ai], 0, g_ai >= ELEMENT_COUNT);\r\n    temp[s_bi] = select(items[g_bi], 0, g_bi >= ELEMENT_COUNT);\r\n\r\n    var offset: u32 = 1;\r\n\r\n    // Up-sweep (reduce) phase\r\n    for (var d: u32 = ITEMS_PER_WORKGROUP >> 1; d > 0; d >>= 1) {\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            ai += get_offset(ai);\r\n            bi += get_offset(bi);\r\n            temp[bi] += temp[ai];\r\n        }\r\n\r\n        offset *= 2;\r\n    }\r\n\r\n    // Save workgroup sum and clear last element\r\n    if (TID == 0) {\r\n        var last_offset = ITEMS_PER_WORKGROUP - 1;\r\n        last_offset += get_offset(last_offset);\r\n\r\n        blockSums[WORKGROUP_ID] = temp[last_offset];\r\n        temp[last_offset] = 0;\r\n    }\r\n\r\n    // Down-sweep phase\r\n    for (var d: u32 = 1; d < ITEMS_PER_WORKGROUP; d *= 2) {\r\n        offset >>= 1;\r\n        workgroupBarrier();\r\n\r\n        if (TID < d) {\r\n            var ai: u32 = offset * (ELM_TID + 1) - 1;\r\n            var bi: u32 = offset * (ELM_TID + 2) - 1;\r\n            ai += get_offset(ai);\r\n            bi += get_offset(bi);\r\n\r\n            let t: u32 = temp[ai];\r\n            temp[ai] = temp[bi];\r\n            temp[bi] += t;\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Copy result from shared memory to global memory\r\n    if (g_ai < ELEMENT_COUNT) {\r\n        items[g_ai] = temp[s_ai];\r\n    }\r\n    if (g_bi < ELEMENT_COUNT) {\r\n        items[g_bi] = temp[s_bi];\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn add_block_sums(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    let ELM_ID = GID * 2;\r\n\r\n    if (ELM_ID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    let blockSum = blockSums[WORKGROUP_ID];\r\n\r\n    items[ELM_ID] += blockSum;\r\n\r\n    if (ELM_ID + 1 >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    items[ELM_ID + 1] += blockSum;\r\n}`\r\n\r\nexport default prefixSumNoBankConflictSource","/**\r\n * Find the best dispatch size x and y dimensions to minimize unused workgroups\r\n * \r\n * @param {GPUDevice} device - The GPU device\r\n * @param {int} workgroup_count - Number of workgroups to dispatch\r\n * @returns \r\n */\r\nfunction find_optimal_dispatch_size(device, workgroup_count) {\r\n    const dispatchSize = { \r\n        x: workgroup_count, \r\n        y: 1\r\n    }\r\n\r\n    if (workgroup_count > device.limits.maxComputeWorkgroupsPerDimension) {\r\n        const x = Math.floor(Math.sqrt(workgroup_count))\r\n        const y = Math.ceil(workgroup_count / x)\r\n        \r\n        dispatchSize.x = x\r\n        dispatchSize.y = y\r\n    }\r\n\r\n    return dispatchSize\r\n}\r\n\r\nfunction create_buffer_from_data({device, label, data, usage = 0}) {\r\n    const dispatchSizes = device.createBuffer({\r\n        label: label,\r\n        usage: usage,\r\n        size: data.length * 4,\r\n        mappedAtCreation: true\r\n    })\r\n\r\n    const dispatchData = new Uint32Array(dispatchSizes.getMappedRange())\r\n    dispatchData.set(data)\r\n    dispatchSizes.unmap()\r\n\r\n    return dispatchSizes\r\n}\r\n\r\nexport {\r\n    find_optimal_dispatch_size,\r\n    create_buffer_from_data,\r\n}","import prefixSumSource from \"./shaders/prefix_sum\"\r\nimport prefixSumSource_NoBankConflict from \"./shaders/optimizations/prefix_sum_no_bank_conflict\"\r\nimport { find_optimal_dispatch_size } from \"./utils\"\r\n\r\nclass PrefixSumKernel {\r\n    /**\r\n     * Perform a parallel prefix sum on the given data buffer\r\n     * \r\n     * Based on \"Parallel Prefix Sum (Scan) with CUDA\"\r\n     * https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} data - Buffer containing the data to process\r\n     * @param {number} count - Max number of elements to process\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} avoid_bank_conflicts - Use the \"Avoid bank conflicts\" optimization from the original publication\r\n     */\r\n    constructor({\r\n        device,\r\n        data,\r\n        count,\r\n        workgroup_size = { x: 16, y: 16 },\r\n        avoid_bank_conflicts = false\r\n    }) {\r\n        this.device = device\r\n        this.workgroup_size = workgroup_size\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        this.items_per_workgroup = 2 * this.threads_per_workgroup // 2 items are processed per thread\r\n\r\n        if (Math.log2(this.threads_per_workgroup) % 1 !== 0) \r\n            throw new Error(`workgroup_size.x * workgroup_size.y must be a power of two. (current: ${this.threads_per_workgroup})`)\r\n\r\n        this.pipelines = []\r\n\r\n        this.shaderModule = this.device.createShaderModule({\r\n            label: 'prefix-sum',\r\n            code: avoid_bank_conflicts ? prefixSumSource_NoBankConflict : prefixSumSource,\r\n        })\r\n\r\n        this.create_pass_recursive(data, count)\r\n    }\r\n\r\n    create_pass_recursive(data, count) {\r\n        // Find best dispatch x and y dimensions to minimize unused threads\r\n        const workgroup_count = Math.ceil(count / this.items_per_workgroup)\r\n        const dispatchSize = find_optimal_dispatch_size(this.device, workgroup_count)\r\n        \r\n        // Create buffer for block sums        \r\n        const blockSumBuffer = this.device.createBuffer({\r\n            label: 'prefix-sum-block-sum',\r\n            size: workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Create bind group and pipeline layout\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            label: 'prefix-sum-bind-group',\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: data }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: blockSumBuffer }\r\n                }\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        // Per-workgroup (block) prefix sum\r\n        const scanPipeline = this.device.createComputePipeline({\r\n            label: 'prefix-sum-scan-pipeline',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModule,\r\n                entryPoint: 'reduce_downsweep',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ITEMS_PER_WORKGROUP': this.items_per_workgroup,\r\n                    'ELEMENT_COUNT': count,\r\n                }\r\n            }\r\n        })\r\n\r\n        this.pipelines.push({ pipeline: scanPipeline, bindGroup, dispatchSize })\r\n\r\n        if (workgroup_count > 1) {\r\n            // Prefix sum on block sums\r\n            this.create_pass_recursive(blockSumBuffer, workgroup_count)\r\n\r\n            // Add block sums to local prefix sums\r\n            const blockSumPipeline = this.device.createComputePipeline({\r\n                label: 'prefix-sum-add-block-pipeline',\r\n                layout: pipelineLayout,\r\n                compute: {\r\n                    module: this.shaderModule,\r\n                    entryPoint: 'add_block_sums',\r\n                    constants: {\r\n                        'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                        'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                        'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                        'ELEMENT_COUNT': count,\r\n                    }\r\n                }\r\n            })\r\n\r\n            this.pipelines.push({ pipeline: blockSumPipeline, bindGroup, dispatchSize })\r\n        }\r\n    }\r\n\r\n    get_dispatch_chain() {\r\n        return this.pipelines.flatMap(p => [ p.dispatchSize.x, p.dispatchSize.y, 1 ])\r\n    }\r\n\r\n    /**\r\n     * Encode the prefix sum pipeline into the current pass.\r\n     * If dispatchSizeBuffer is provided, the dispatch will be indirect (dispatchWorkgroupsIndirect)\r\n     * \r\n     * @param {GPUComputePassEncoder} pass \r\n     * @param {GPUBuffer} dispatchSizeBuffer - (optional) Indirect dispatch buffer\r\n     * @param {int} offset - (optional) Offset in bytes in the dispatch buffer. Default: 0\r\n     */\r\n    dispatch(pass, dispatchSizeBuffer, offset = 0) {\r\n        for (let i = 0; i < this.pipelines.length; i++) {\r\n            const { pipeline, bindGroup, dispatchSize } = this.pipelines[i]\r\n            \r\n            pass.setPipeline(pipeline)\r\n            pass.setBindGroup(0, bindGroup)\r\n\r\n            if (dispatchSizeBuffer == null)\r\n                pass.dispatchWorkgroups(dispatchSize.x, dispatchSize.y, 1)\r\n            else\r\n                pass.dispatchWorkgroupsIndirect(dispatchSizeBuffer, offset + i * 3 * 4)\r\n        }\r\n    }\r\n}\r\n\r\nexport default PrefixSumKernel","const radixSortSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    // Extract 2 bits from the input\r\n    let elm = select(input[GID], 0, GID >= ELEMENT_COUNT);\r\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\r\n\r\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\r\n\r\n    // If the workgroup is inactive, prevent block_sums buffer update\r\n    var LAST_THREAD: u32 = 0xffffffff; \r\n\r\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\r\n        // Otherwise store the index of the last active thread in the workgroup\r\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n    }\r\n\r\n    // Initialize parameters for double-buffering\r\n    let TPW = THREADS_PER_WORKGROUP + 1;\r\n    var swapOffset: u32 = 0;\r\n    var inOffset:  u32 = TID;\r\n    var outOffset: u32 = TID + TPW;\r\n\r\n    // 4-way prefix sum\r\n    for (var b: u32 = 0; b < 4; b++) {\r\n        // Initialize local prefix with bitmask\r\n        let bitmask = select(0u, 1u, extract_bits == b);\r\n        s_prefix_sum[inOffset + 1] = bitmask;\r\n        workgroupBarrier();\r\n\r\n        var prefix_sum: u32 = 0;\r\n\r\n        // Prefix sum\r\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\r\n            if (TID >= offset) {\r\n                prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\r\n            } else {\r\n                prefix_sum = s_prefix_sum[inOffset];\r\n            }\r\n\r\n            s_prefix_sum[outOffset] = prefix_sum;\r\n            \r\n            // Swap buffers\r\n            outOffset = inOffset;\r\n            swapOffset = TPW - swapOffset;\r\n            inOffset = TID + swapOffset;\r\n            \r\n            workgroupBarrier();\r\n        }\r\n\r\n        // Store prefix sum for current bit\r\n        bit_prefix_sums[b] = prefix_sum;\r\n\r\n        if (TID == LAST_THREAD) {\r\n            // Store block sum to global memory\r\n            let total_sum: u32 = prefix_sum + bitmask;\r\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\r\n        }\r\n\r\n        // Swap buffers\r\n        outOffset = inOffset;\r\n        swapOffset = TPW - swapOffset;\r\n        inOffset = TID + swapOffset;\r\n    }\r\n\r\n    if (GID < ELEMENT_COUNT) {\r\n        // Store local prefix sum to global memory\r\n        local_prefix_sums[GID] = bit_prefix_sums[extract_bits];\r\n    }\r\n}`\r\n\r\nexport default radixSortSource;","/**\r\n * Radix sort with \"local shuffle and coalesced mapping\" optimization\r\n * \r\n * (see Implementation section in README for details)\r\n */\r\nconst radixSortCoalescedSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read_write> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\r\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\r\n@group(0) @binding(3) var<storage, read_write> values: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\nvar<workgroup> s_prefix_sum: array<u32, 2 * (THREADS_PER_WORKGROUP + 1)>;\r\nvar<workgroup> s_prefix_sum_scan: array<u32, 4>;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    // Extract 2 bits from the input\r\n    var elm: u32 = 0;\r\n    var val: u32 = 0;\r\n    if (GID < ELEMENT_COUNT) {\r\n        elm = input[GID];\r\n        val = values[GID];\r\n    }\r\n    let extract_bits: u32 = (elm >> CURRENT_BIT) & 0x3;\r\n\r\n    var bit_prefix_sums = array<u32, 4>(0, 0, 0, 0);\r\n\r\n    // If the workgroup is inactive, prevent block_sums buffer update\r\n    var LAST_THREAD: u32 = 0xffffffff; \r\n\r\n    if (WORKGROUP_ID < WORKGROUP_COUNT) {\r\n        // Otherwise store the index of the last active thread in the workgroup\r\n        LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n    }\r\n\r\n    // Initialize parameters for double-buffering\r\n    let TPW = THREADS_PER_WORKGROUP + 1;\r\n    var swapOffset: u32 = 0;\r\n    var inOffset:  u32 = TID;\r\n    var outOffset: u32 = TID + TPW;\r\n\r\n    // 4-way prefix sum\r\n    for (var b: u32 = 0; b < 4; b++) {\r\n        // Initialize local prefix with bitmask\r\n        let bitmask = select(0u, 1u, extract_bits == b);\r\n        s_prefix_sum[inOffset + 1] = bitmask;\r\n        workgroupBarrier();\r\n\r\n        var prefix_sum: u32 = 0;\r\n\r\n        // Prefix sum\r\n        for (var offset: u32 = 1; offset < THREADS_PER_WORKGROUP; offset *= 2) {\r\n            if (TID >= offset) {\r\n                prefix_sum = s_prefix_sum[inOffset] + s_prefix_sum[inOffset - offset];\r\n            } else {\r\n                prefix_sum = s_prefix_sum[inOffset];\r\n            }\r\n\r\n            s_prefix_sum[outOffset] = prefix_sum;\r\n\r\n            // Swap buffers\r\n            outOffset = inOffset;\r\n            swapOffset = TPW - swapOffset;\r\n            inOffset = TID + swapOffset;\r\n            \r\n            workgroupBarrier();\r\n        }\r\n\r\n        // Store prefix sum for current bit\r\n        bit_prefix_sums[b] = prefix_sum;\r\n\r\n        if (TID == LAST_THREAD) {\r\n            // Store block sum to global memory\r\n            let total_sum: u32 = prefix_sum + bitmask;\r\n            block_sums[b * WORKGROUP_COUNT + WORKGROUP_ID] = total_sum;\r\n        }\r\n\r\n        // Swap buffers\r\n        outOffset = inOffset;\r\n        swapOffset = TPW - swapOffset;\r\n        inOffset = TID + swapOffset;\r\n    }\r\n\r\n    let prefix_sum = bit_prefix_sums[extract_bits];   \r\n\r\n    // Scan bit prefix sums\r\n    if (TID == LAST_THREAD) {\r\n        var sum: u32 = 0;\r\n        bit_prefix_sums[extract_bits] += 1;\r\n        for (var i: u32 = 0; i < 4; i++) {\r\n            s_prefix_sum_scan[i] = sum;\r\n            sum += bit_prefix_sums[i];\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    if (GID < ELEMENT_COUNT) {\r\n        // Compute new position\r\n        let new_pos: u32 = prefix_sum + s_prefix_sum_scan[extract_bits];\r\n\r\n        // Shuffle elements locally\r\n        input[WID + new_pos] = elm;\r\n        values[WID + new_pos] = val;\r\n        local_prefix_sums[WID + new_pos] = prefix_sum;\r\n    }\r\n}`\r\n\r\nexport default radixSortCoalescedSource;","const radixSortReorderSource = /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> inputKeys: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> outputKeys: array<u32>;\r\n@group(0) @binding(2) var<storage, read> local_prefix_sum: array<u32>;\r\n@group(0) @binding(3) var<storage, read> prefix_block_sum: array<u32>;\r\n@group(0) @binding(4) var<storage, read> inputValues: array<u32>;\r\n@group(0) @binding(5) var<storage, read_write> outputValues: array<u32>;\r\n\r\noverride WORKGROUP_COUNT: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride CURRENT_BIT: u32;\r\noverride ELEMENT_COUNT: u32;\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn radix_sort_reorder(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) { \r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\r\n    let GID = WID + TID; // Global thread ID\r\n\r\n    if (GID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    let k = inputKeys[GID];\r\n    let v = inputValues[GID];\r\n\r\n    let local_prefix = local_prefix_sum[GID];\r\n\r\n    // Calculate new position\r\n    let extract_bits = (k >> CURRENT_BIT) & 0x3;\r\n    let pid = extract_bits * WORKGROUP_COUNT + WORKGROUP_ID;\r\n    let sorted_position = prefix_block_sum[pid] + local_prefix;\r\n    \r\n    outputKeys[sorted_position] = k;\r\n    outputValues[sorted_position] = v;\r\n}`\r\n\r\nexport default radixSortReorderSource;","const checkSortSource = (isFirstPass = false, isLastPass = false, kernelMode = 'full') => /* wgsl */ `\r\n\r\n@group(0) @binding(0) var<storage, read> input: array<u32>;\r\n@group(0) @binding(1) var<storage, read_write> output: array<u32>;\r\n@group(0) @binding(2) var<storage, read> original: array<u32>;\r\n@group(0) @binding(3) var<storage, read_write> is_sorted: u32;\r\n\r\noverride WORKGROUP_SIZE_X: u32;\r\noverride WORKGROUP_SIZE_Y: u32;\r\noverride THREADS_PER_WORKGROUP: u32;\r\noverride ELEMENT_COUNT: u32;\r\noverride START_ELEMENT: u32;\r\n\r\nvar<workgroup> s_data: array<u32, THREADS_PER_WORKGROUP>;\r\n\r\n// Reset dispatch buffer and is_sorted flag\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn reset(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    if (TID >= ELEMENT_COUNT) {\r\n        return;\r\n    }\r\n\r\n    if (TID == 0) {\r\n        is_sorted = 0u;\r\n    }\r\n\r\n    let ELM_ID = TID * 3;\r\n\r\n    output[ELM_ID] = original[ELM_ID];\r\n}\r\n\r\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\r\nfn check_sort(\r\n    @builtin(workgroup_id) w_id: vec3<u32>,\r\n    @builtin(num_workgroups) w_dim: vec3<u32>,\r\n    @builtin(local_invocation_index) TID: u32, // Local thread ID\r\n) {\r\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\r\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP + START_ELEMENT;\r\n    let GID = TID + WID; // Global thread ID\r\n\r\n    // Load data into shared memory\r\n    ${ isFirstPass ? first_pass_load_data : \"s_data[TID] = select(0u, input[GID], GID < ELEMENT_COUNT);\" }\r\n\r\n    // Perform parallel reduction\r\n    for (var d = 1u; d < THREADS_PER_WORKGROUP; d *= 2u) {      \r\n        workgroupBarrier();  \r\n        if (TID % (2u * d) == 0u) {\r\n            s_data[TID] += s_data[TID + d];\r\n        }\r\n    }\r\n    workgroupBarrier();\r\n\r\n    // Write reduction result\r\n    ${ isLastPass ? last_pass(kernelMode) : write_reduction_result }\r\n}`\r\n\r\nconst write_reduction_result = /* wgsl */ `\r\n    if (TID == 0) {\r\n        output[WORKGROUP_ID] = s_data[0];\r\n    }\r\n`\r\n\r\nconst first_pass_load_data = /* wgsl */ `\r\n    let LAST_THREAD = min(THREADS_PER_WORKGROUP, ELEMENT_COUNT - WID) - 1;\r\n\r\n    // Load current element into shared memory\r\n    // Also load next element for comparison\r\n    let elm = select(0u, input[GID], GID < ELEMENT_COUNT);\r\n    let next = select(0u, input[GID + 1], GID < ELEMENT_COUNT-1);\r\n    s_data[TID] = elm;\r\n    workgroupBarrier();\r\n\r\n    s_data[TID] = select(0u, 1u, GID < ELEMENT_COUNT-1 && elm > next);\r\n`\r\n\r\nconst last_pass = (kernelMode) => /* wgsl */ `\r\n    let fullDispatchLength = arrayLength(&output);\r\n    let dispatchIndex = TID * 3;\r\n\r\n    if (dispatchIndex >= fullDispatchLength) {\r\n        return;\r\n    }\r\n\r\n    ${kernelMode == 'full' ? last_pass_full : last_pass_fast}\r\n`\r\n\r\n// If the fast check kernel is sorted and the data isn't already sorted, run the full check\r\nconst last_pass_fast = /* wgsl */ `\r\n    output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] == 0 && is_sorted == 0u);\r\n`\r\n\r\n// If the full check kernel is sorted, set the flag to 1 and skip radix sort passes\r\nconst last_pass_full = /* wgsl */ `\r\n    if (TID == 0 && s_data[0] == 0) {\r\n        is_sorted = 1u;\r\n    }\r\n\r\n    output[dispatchIndex] = select(0, original[dispatchIndex], s_data[0] != 0);\r\n`\r\nexport default checkSortSource","import checkSortSource from \"./shaders/check_sort\"\r\nimport { find_optimal_dispatch_size } from \"./utils\"\r\n\r\nclass CheckSortKernel {\r\n    /**\r\n     * CheckSortKernel - Performs a parralel reduction to check if an array is sorted.\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} data - The buffer containing the data to check\r\n     * @param {GPUBuffer} result - The result dispatch size buffer\r\n     * @param {GPUBuffer} original - The original dispatch size buffer\r\n     * @param {GPUBuffer} is_sorted - 1-element buffer to store whether the array is sorted\r\n     * @param {number} count - The number of elements to check\r\n     * @param {number} start - The index to start checking from\r\n     * @param {boolean} mode - The type of check sort kernel ('reset', 'fast', 'full')\r\n     * @param {object} workgroup_size - The workgroup size in x and y dimensions\r\n     */\r\n    constructor({\r\n        device,\r\n        data,\r\n        result,\r\n        original,\r\n        is_sorted,\r\n        count,\r\n        start = 0,\r\n        mode = 'full',\r\n        workgroup_size = { x: 16, y: 16 },\r\n    }) {\r\n        this.device = device\r\n        this.count = count\r\n        this.start = start\r\n        this.mode = mode\r\n        this.workgroup_size = workgroup_size\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n\r\n        this.pipelines = []\r\n\r\n        this.buffers = {\r\n            data, \r\n            result, \r\n            original, \r\n            is_sorted,\r\n            outputs: []\r\n        }\r\n\r\n        this.create_passes_recursive(data, count)\r\n    }\r\n\r\n    // Find the best dispatch size for each pass to minimize unused workgroups\r\n    static find_optimal_dispatch_chain(device, item_count, workgroup_size) {\r\n        const threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        const sizes = []\r\n\r\n        do {\r\n            // Number of workgroups required to process all items\r\n            const target_workgroup_count = Math.ceil(item_count / threads_per_workgroup)\r\n    \r\n            // Optimal dispatch size and updated workgroup count\r\n            const dispatchSize = find_optimal_dispatch_size(device, target_workgroup_count)\r\n    \r\n            sizes.push(dispatchSize.x, dispatchSize.y, 1)\r\n            item_count = target_workgroup_count\r\n        } while (item_count > 1)\r\n    \r\n        return sizes\r\n    }\r\n\r\n    create_passes_recursive(buffer, count, passIndex = 0) {\r\n        const workgroup_count = Math.ceil(count / this.threads_per_workgroup)\r\n\r\n        const isFirstPass = passIndex === 0\r\n        const isLastPass = workgroup_count <= 1\r\n\r\n        const label = `check-sort-${this.mode}-${passIndex}`\r\n\r\n        const outputBuffer = isLastPass ? this.buffers.result : this.device.createBuffer({\r\n            label: label,\r\n            size: workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                // Last pass bindings\r\n                ...(isLastPass ? [{\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                }, {\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }] : []),\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: buffer }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: outputBuffer }\r\n                },\r\n                // Last pass buffers\r\n                ...(isLastPass ? [{\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.original }\r\n                }, {\r\n                    binding: 3,\r\n                    resource: { buffer: this.buffers.is_sorted }\r\n                }] : []),\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [bindGroupLayout]\r\n        })\r\n\r\n        const element_count = isFirstPass ? this.start + count : count\r\n        const start_element = isFirstPass ? this.start : 0\r\n\r\n        const checkSortPipeline = this.device.createComputePipeline({\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.device.createShaderModule({\r\n                    label: label,\r\n                    code: checkSortSource(isFirstPass, isLastPass, this.mode),\r\n                }),\r\n                entryPoint: this.mode == 'reset' ? 'reset' : 'check_sort',\r\n                constants: {\r\n                    'ELEMENT_COUNT': element_count,\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    ...(this.mode != 'reset' && { \r\n                        'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                        'START_ELEMENT': start_element,\r\n                    })\r\n                },\r\n            }\r\n        })\r\n\r\n        this.buffers.outputs.push(outputBuffer)\r\n        this.pipelines.push({ pipeline: checkSortPipeline, bindGroup })\r\n        \r\n        if (!isLastPass) {\r\n            this.create_passes_recursive(outputBuffer, workgroup_count, passIndex + 1)\r\n        }\r\n    }\r\n\r\n    dispatch(pass, dispatchSize, offset = 0) {\r\n        for (let i = 0; i < this.pipelines.length; i++) {\r\n            const { pipeline, bindGroup } = this.pipelines[i]\r\n\r\n            const dispatchIndirect = this.mode != 'reset' && (this.mode == 'full' || i < this.pipelines.length - 1)\r\n\r\n            pass.setPipeline(pipeline)\r\n            pass.setBindGroup(0, bindGroup)\r\n\r\n            if (dispatchIndirect)\r\n                pass.dispatchWorkgroupsIndirect(dispatchSize, offset + i * 3 * 4)\r\n            else\r\n                // Only the reset kernel and the last dispatch of the fast check kernel are constant to (1, 1, 1)\r\n                pass.dispatchWorkgroups(1, 1, 1)\r\n        }\r\n    }\r\n}\r\n\r\nexport default CheckSortKernel","import PrefixSumKernel from \"./PrefixSumKernel\"\r\nimport radixSortSource from \"./shaders/radix_sort\"\r\nimport radixSortSource_LocalShuffle from \"./shaders/optimizations/radix_sort_local_shuffle\"\r\nimport reorderSource from \"./shaders/radix_sort_reorder\"\r\nimport CheckSortKernel from \"./CheckSortKernel\"\r\nimport { create_buffer_from_data, find_optimal_dispatch_size } from \"./utils\"\r\n\r\nclass RadixSortKernel {\r\n    /**\r\n     * Perform a parallel radix sort on the GPU given a buffer of keys and (optionnaly) values\r\n     * Note: The buffers are sorted in-place.\r\n     * \r\n     * Based on \"Fast 4-way parallel radix sorting on GPUs\"\r\n     * https://www.sci.utah.edu/~csilva/papers/cgf.pdf]\r\n     * \r\n     * @param {GPUDevice} device\r\n     * @param {GPUBuffer} keys - Buffer containing the keys to sort\r\n     * @param {GPUBuffer} values - (optional) Buffer containing the associated values\r\n     * @param {number} count - Number of elements to sort\r\n     * @param {number} bit_count - Number of bits per element (default: 32)\r\n     * @param {object} workgroup_size - Workgroup size in x and y dimensions. (x * y) must be a power of two\r\n     * @param {boolean} check_order - Enable \"order checking\" optimization. Can improve performance if the data needs to be sorted in real-time and doesn't change much. (default: false)\r\n     * @param {boolean} local_shuffle - Enable \"local shuffling\" optimization for the radix sort kernel (default: false)\r\n     * @param {boolean} avoid_bank_conflicts - Enable \"avoiding bank conflicts\" optimization for the prefix sum kernel (default: false)\r\n     */\r\n    constructor({\r\n        device,\r\n        keys,\r\n        values,\r\n        count,\r\n        bit_count = 32,\r\n        workgroup_size = { x: 16, y: 16 },\r\n        check_order = false,\r\n        local_shuffle = false,\r\n        avoid_bank_conflicts = false,\r\n    } = {}) {\r\n        if (device == null) throw new Error('No device provided')\r\n        if (keys == null) throw new Error('No keys buffer provided')\r\n        if (!Number.isInteger(count) || count <= 0) throw new Error('Invalid count parameter')\r\n        if (!Number.isInteger(bit_count) || bit_count <= 0 || bit_count > 32) throw new Error(`Invalid bit_count parameter: ${bit_count}`)\r\n        if (!Number.isInteger(workgroup_size.x) || !Number.isInteger(workgroup_size.y)) throw new Error('Invalid workgroup_size parameter')\r\n        if (bit_count % 4 != 0) throw new Error('bit_count must be a multiple of 4')\r\n\r\n        this.device = device\r\n        this.count = count\r\n        this.bit_count = bit_count\r\n        this.workgroup_size = workgroup_size\r\n        this.check_order = check_order\r\n        this.local_shuffle = local_shuffle\r\n        this.avoid_bank_conflicts = avoid_bank_conflicts\r\n\r\n        this.threads_per_workgroup = workgroup_size.x * workgroup_size.y\r\n        this.workgroup_count = Math.ceil(count / this.threads_per_workgroup)\r\n        this.prefix_block_workgroup_count = 4 * this.workgroup_count\r\n\r\n        this.has_values = (values != null) // Is the values buffer provided ?\r\n\r\n        this.dispatchSize = {}  // Dispatch dimension x and y\r\n        this.shaderModules = {} // GPUShaderModules\r\n        this.kernels = {}       // PrefixSumKernel & CheckSortKernels\r\n        this.pipelines = []     // List of passes\r\n        this.buffers = {        // GPUBuffers\r\n            keys: keys,\r\n            values: values\r\n        }       \r\n\r\n        // Create shader modules from wgsl code\r\n        this.create_shader_modules()\r\n        \r\n        // Create multi-pass pipelines\r\n        this.create_pipelines()\r\n    }\r\n\r\n    create_shader_modules() {\r\n        // Remove every occurence of \"values\" in the shader code if values buffer is not provided\r\n        const remove_values = (source) => {\r\n            return source.split('\\n')\r\n                         .filter(line => !line.toLowerCase().includes('values'))\r\n                         .join('\\n')\r\n        }\r\n\r\n        const blockSumSource = this.local_shuffle ? radixSortSource_LocalShuffle : radixSortSource\r\n        \r\n        this.shaderModules = {\r\n            blockSum: this.device.createShaderModule({\r\n                label: 'radix-sort-block-sum',\r\n                code: this.has_values ? blockSumSource : remove_values(blockSumSource),\r\n            }),\r\n            reorder: this.device.createShaderModule({\r\n                label: 'radix-sort-reorder',\r\n                code: this.has_values ? reorderSource : remove_values(reorderSource),\r\n            })\r\n        }\r\n    }\r\n\r\n    create_pipelines() {    \r\n        // Block prefix sum kernel    \r\n        this.create_prefix_sum_kernel()\r\n\r\n        // Indirect dispatch buffers\r\n        const dispatchData = this.calculate_dispatch_sizes()\r\n\r\n        // GPU buffers\r\n        this.create_buffers(dispatchData)\r\n\r\n        // Check sort kernels\r\n        this.create_check_sort_kernels(dispatchData)\r\n\r\n        // Radix sort passes for every 2 bits\r\n        for (let bit = 0; bit < this.bit_count; bit += 2) {\r\n            // Swap buffers every pass\r\n            const even      = (bit % 4 == 0)\r\n            const inKeys    = even ? this.buffers.keys : this.buffers.tmpKeys\r\n            const inValues  = even ? this.buffers.values : this.buffers.tmpValues\r\n            const outKeys   = even ? this.buffers.tmpKeys : this.buffers.keys\r\n            const outValues = even ? this.buffers.tmpValues : this.buffers.values\r\n\r\n            // Compute local prefix sums and block sums\r\n            const blockSumPipeline = this.create_block_sum_pipeline(inKeys, inValues, bit)\r\n            \r\n            // Reorder keys and values\r\n            const reorderPipeline = this.create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit)\r\n\r\n            this.pipelines.push({ blockSumPipeline, reorderPipeline })\r\n        }\r\n    }\r\n\r\n    create_prefix_sum_kernel() {\r\n        // Prefix Block Sum buffer (4 element per workgroup)\r\n        const prefixBlockSumBuffer = this.device.createBuffer({\r\n            label: 'radix-sort-prefix-block-sum',\r\n            size: this.prefix_block_workgroup_count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Create block prefix sum kernel\r\n        const prefixSumKernel = new PrefixSumKernel({ \r\n            device: this.device,\r\n            data: prefixBlockSumBuffer, \r\n            count: this.prefix_block_workgroup_count,\r\n            workgroup_size: this.workgroup_size,\r\n            avoid_bank_conflicts: this.avoid_bank_conflicts,\r\n        })\r\n\r\n        this.kernels.prefixSum = prefixSumKernel\r\n        this.buffers.prefixBlockSum = prefixBlockSumBuffer\r\n    }\r\n\r\n    calculate_dispatch_sizes() {\r\n        // Radix sort dispatch size\r\n        const dispatchSize = find_optimal_dispatch_size(this.device, this.workgroup_count)\r\n\r\n        // Prefix sum dispatch sizes\r\n        const prefixSumDispatchSize = this.kernels.prefixSum.get_dispatch_chain()\r\n\r\n        // Check sort element count (fast/full)\r\n        const check_sort_fast_count = Math.min(this.count, this.threads_per_workgroup * 4)\r\n        const check_sort_full_count = this.count - check_sort_fast_count\r\n        const start_full = check_sort_fast_count - 1\r\n\r\n        // Check sort dispatch sizes\r\n        const dispatchSizesFast = CheckSortKernel.find_optimal_dispatch_chain(this.device, check_sort_fast_count, this.workgroup_size)\r\n        const dispatchSizesFull = CheckSortKernel.find_optimal_dispatch_chain(this.device, check_sort_full_count, this.workgroup_size)\r\n\r\n        // Initial dispatch sizes\r\n        const initialDispatch = [\r\n            dispatchSize.x, dispatchSize.y, 1, // Radix Sort + Reorder\r\n            ...dispatchSizesFast.slice(0, 3),  // Check sort fast\r\n            ...prefixSumDispatchSize           // Prefix Sum\r\n        ]\r\n\r\n        // Dispatch offsets in main buffer\r\n        this.dispatchOffsets = {\r\n            radix_sort: 0,\r\n            check_sort_fast: 3 * 4,\r\n            prefix_sum: 6 * 4\r\n        }\r\n\r\n        this.dispatchSize = dispatchSize\r\n        this.initialDispatch = initialDispatch\r\n\r\n        return {\r\n            initialDispatch,\r\n            dispatchSizesFull,\r\n            check_sort_fast_count, \r\n            check_sort_full_count, \r\n            start_full \r\n        }\r\n    }\r\n\r\n    create_buffers(dispatchData) {\r\n        // Keys and values double buffering\r\n        const tmpKeysBuffer = this.device.createBuffer({\r\n            label: 'radix-sort-tmp-keys',\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n        const tmpValuesBuffer = !this.has_values ? null : this.device.createBuffer({\r\n            label: 'radix-sort-tmp-values',\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        // Local Prefix Sum buffer (1 element per item)\r\n        const localPrefixSumBuffer = this.device.createBuffer({\r\n            label: 'radix-sort-local-prefix-sum',\r\n            size: this.count * 4,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        this.buffers.tmpKeys = tmpKeysBuffer\r\n        this.buffers.tmpValues = tmpValuesBuffer\r\n        this.buffers.localPrefixSum = localPrefixSumBuffer\r\n\r\n        // Only create indirect dispatch buffers when check_order optimization is enabled\r\n        if (!this.check_order) {\r\n            return\r\n        }\r\n\r\n        // Dispatch sizes (radix sort, check sort, prefix sum)\r\n        const dispatchBuffer = create_buffer_from_data({\r\n            device: this.device, \r\n            label: 'radix-sort-dispatch-size',\r\n            data: dispatchData.initialDispatch, \r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT\r\n        })\r\n        const originalDispatchBuffer = create_buffer_from_data({\r\n            device: this.device, \r\n            label: 'radix-sort-dispatch-size-original',\r\n            data: dispatchData.initialDispatch, \r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\r\n        })\r\n\r\n        // Dispatch sizes (full sort)\r\n        const checkSortFullDispatchBuffer = create_buffer_from_data({\r\n            label: 'check-sort-full-dispatch-size',\r\n            device: this.device, \r\n            data: dispatchData.dispatchSizesFull,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.INDIRECT\r\n        })\r\n        const checkSortFullOriginalDispatchBuffer = create_buffer_from_data({\r\n            label: 'check-sort-full-dispatch-size-original',\r\n            device: this.device, \r\n            data: dispatchData.dispatchSizesFull,\r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC\r\n        })\r\n\r\n        // Flag to tell if the data is sorted\r\n        const isSortedBuffer = create_buffer_from_data({\r\n            label: 'is-sorted',\r\n            device: this.device, \r\n            data: new Uint32Array([0]), \r\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\r\n        })\r\n\r\n        this.buffers.dispatchSize = dispatchBuffer\r\n        this.buffers.originalDispatchSize = originalDispatchBuffer\r\n        this.buffers.checkSortFullDispatchSize = checkSortFullDispatchBuffer\r\n        this.buffers.originalCheckSortFullDispatchSize = checkSortFullOriginalDispatchBuffer\r\n        this.buffers.isSorted = isSortedBuffer\r\n    }\r\n\r\n    create_check_sort_kernels(checkSortPartitionData) {\r\n        if (!this.check_order) {\r\n            return\r\n        }\r\n\r\n        const { check_sort_fast_count, check_sort_full_count, start_full } = checkSortPartitionData\r\n\r\n        // Create the full pass\r\n        const checkSortFull = new CheckSortKernel({\r\n            mode: 'full',\r\n            device: this.device,\r\n            data: this.buffers.keys,\r\n            result: this.buffers.dispatchSize,\r\n            original: this.buffers.originalDispatchSize,\r\n            is_sorted: this.buffers.isSorted,\r\n            count: check_sort_full_count,\r\n            start: start_full,\r\n            workgroup_size: this.workgroup_size\r\n        })\r\n\r\n        // Create the fast pass\r\n        const checkSortFast = new CheckSortKernel({\r\n            mode: 'fast',\r\n            device: this.device,\r\n            data: this.buffers.keys,\r\n            result: this.buffers.checkSortFullDispatchSize,\r\n            original: this.buffers.originalCheckSortFullDispatchSize,\r\n            is_sorted: this.buffers.isSorted,\r\n            count: check_sort_fast_count,\r\n            workgroup_size: this.workgroup_size\r\n        })\r\n\r\n        const initialDispatchElementCount = this.initialDispatch.length / 3\r\n\r\n        if (checkSortFast.threads_per_workgroup < checkSortFull.pipelines.length || checkSortFull.threads_per_workgroup < initialDispatchElementCount) {\r\n            console.warn(`Warning: workgroup size is too small to enable check sort optimization, disabling...`)\r\n            this.check_order = false\r\n            return\r\n        }\r\n\r\n        // Create the reset pass\r\n        const checkSortReset = new CheckSortKernel({\r\n            mode: 'reset',\r\n            device: this.device,\r\n            data: this.buffers.keys,\r\n            original: this.buffers.originalDispatchSize,\r\n            result: this.buffers.dispatchSize,\r\n            is_sorted: this.buffers.isSorted,\r\n            count: initialDispatchElementCount,\r\n            workgroup_size: find_optimal_dispatch_size(this.device, initialDispatchElementCount)\r\n        })\r\n\r\n        this.kernels.checkSort = {\r\n            reset: checkSortReset,\r\n            fast: checkSortFast,\r\n            full: checkSortFull,\r\n        }\r\n    }\r\n\r\n    create_block_sum_pipeline(inKeys, inValues, bit) {\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: 'radix-sort-block-sum',\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: this.local_shuffle ? 'storage' : 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                ...(this.local_shuffle && this.has_values ? [{\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                }] : [])\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: inKeys }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: this.buffers.localPrefixSum }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.prefixBlockSum }\r\n                },\r\n                // \"Local shuffle\" optimization needs access to the values buffer\r\n                ...(this.local_shuffle && this.has_values ? [{\r\n                    binding: 3,\r\n                    resource: { buffer: inValues }\r\n                }] : [])\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        const blockSumPipeline = this.device.createComputePipeline({\r\n            label: 'radix-sort-block-sum',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModules.blockSum,\r\n                entryPoint: 'radix_sort',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'WORKGROUP_COUNT': this.workgroup_count,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': this.count,\r\n                    'CURRENT_BIT': bit,\r\n                }\r\n            }\r\n        })\r\n\r\n        return {\r\n            pipeline: blockSumPipeline,\r\n            bindGroup\r\n        }\r\n    }\r\n\r\n    create_reorder_pipeline(inKeys, inValues, outKeys, outValues, bit) {\r\n        const bindGroupLayout = this.device.createBindGroupLayout({\r\n            label: 'radix-sort-reorder',\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'storage' }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    visibility: GPUShaderStage.COMPUTE,\r\n                    buffer: { type: 'read-only-storage' }\r\n                },\r\n                ...(this.has_values ? [\r\n                    {\r\n                        binding: 4,\r\n                        visibility: GPUShaderStage.COMPUTE,\r\n                        buffer: { type: 'read-only-storage' }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        visibility: GPUShaderStage.COMPUTE,\r\n                        buffer: { type: 'storage' }\r\n                    }\r\n                ] : [])\r\n            ]\r\n        })\r\n\r\n        const bindGroup = this.device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: { buffer: inKeys }\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: { buffer: outKeys }\r\n                },\r\n                {\r\n                    binding: 2,\r\n                    resource: { buffer: this.buffers.localPrefixSum }\r\n                },\r\n                {\r\n                    binding: 3,\r\n                    resource: { buffer: this.buffers.prefixBlockSum }\r\n                },\r\n                ...(this.has_values ? [\r\n                    {\r\n                        binding: 4,\r\n                        resource: { buffer: inValues }\r\n                    },\r\n                    {\r\n                        binding: 5,\r\n                        resource: { buffer: outValues }\r\n                    }\r\n                ] : [])\r\n            ]\r\n        })\r\n\r\n        const pipelineLayout = this.device.createPipelineLayout({\r\n            bindGroupLayouts: [ bindGroupLayout ]\r\n        })\r\n\r\n        const reorderPipeline = this.device.createComputePipeline({\r\n            label: 'radix-sort-reorder',\r\n            layout: pipelineLayout,\r\n            compute: {\r\n                module: this.shaderModules.reorder,\r\n                entryPoint: 'radix_sort_reorder',\r\n                constants: {\r\n                    'WORKGROUP_SIZE_X': this.workgroup_size.x,\r\n                    'WORKGROUP_SIZE_Y': this.workgroup_size.y,\r\n                    'WORKGROUP_COUNT': this.workgroup_count,\r\n                    'THREADS_PER_WORKGROUP': this.threads_per_workgroup,\r\n                    'ELEMENT_COUNT': this.count,\r\n                    'CURRENT_BIT': bit,\r\n                }\r\n            }\r\n        })\r\n\r\n        return {\r\n            pipeline: reorderPipeline,\r\n            bindGroup\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode all pipelines into the current pass\r\n     * \r\n     * @param {GPUComputePassEncoder} pass \r\n     */\r\n    dispatch(pass) {\r\n        if (!this.check_order) {\r\n            this.#dispatchPipelines(pass)\r\n        }\r\n        else {\r\n            this.#dispatchPipelinesIndirect(pass)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispatch workgroups from CPU args\r\n     */\r\n    #dispatchPipelines(pass) {\r\n        for (let i = 0; i < this.bit_count / 2; i++) {\r\n            const { blockSumPipeline, reorderPipeline } = this.pipelines[i]\r\n            \r\n            // Compute local prefix sums and block sums\r\n            pass.setPipeline(blockSumPipeline.pipeline)\r\n            pass.setBindGroup(0, blockSumPipeline.bindGroup)\r\n            pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1)\r\n\r\n            // Compute block sums prefix sum\r\n            this.kernels.prefixSum.dispatch(pass)\r\n\r\n            // Reorder keys and values\r\n            pass.setPipeline(reorderPipeline.pipeline)\r\n            pass.setBindGroup(0, reorderPipeline.bindGroup)\r\n            pass.dispatchWorkgroups(this.dispatchSize.x, this.dispatchSize.y, 1)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispatch workgroups from indirect GPU buffers (used when check_order is enabled)\r\n     */\r\n    #dispatchPipelinesIndirect(pass) {\r\n        // Reset the `dispatch` and `is_sorted` buffers\r\n        this.kernels.checkSort.reset.dispatch(pass)\r\n        \r\n        for (let i = 0; i < this.bit_count / 2; i++) {\r\n            const { blockSumPipeline, reorderPipeline } = this.pipelines[i]\r\n\r\n            if (i % 2 == 0) {\r\n                // Check if the data is sorted every 2 passes\r\n                this.kernels.checkSort.fast.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.check_sort_fast)\r\n                this.kernels.checkSort.full.dispatch(pass, this.buffers.checkSortFullDispatchSize)\r\n            }\r\n            \r\n            // Compute local prefix sums and block sums\r\n            pass.setPipeline(blockSumPipeline.pipeline)\r\n            pass.setBindGroup(0, blockSumPipeline.bindGroup)\r\n            pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize, this.dispatchOffsets.radix_sort)\r\n\r\n            // Compute block sums prefix sum\r\n            this.kernels.prefixSum.dispatch(pass, this.buffers.dispatchSize, this.dispatchOffsets.prefix_sum)\r\n\r\n            // Reorder keys and values\r\n            pass.setPipeline(reorderPipeline.pipeline)\r\n            pass.setBindGroup(0, reorderPipeline.bindGroup)\r\n            pass.dispatchWorkgroupsIndirect(this.buffers.dispatchSize, this.dispatchOffsets.radix_sort)\r\n        }\r\n    }\r\n}\r\n\r\nexport default RadixSortKernel"],"names":["prefixSumSource_NoBankConflict","radixSortSource_LocalShuffle","reorderSource"],"mappings":"AAAA,MAAM,eAAe,cAAc,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AC1GD;AACA;AACA;AACA;AACA;AACA,MAAM,6BAA6B,cAAc,CAAC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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xD,YAAY,MAAM,EAAE,QAAQ,EAAE,SAAS,EAAE,YAAY,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAC;AAC3E;AACA,YAAY,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAC;AACtC,YAAY,IAAI,CAAC,YAAY,CAAC,CAAC,EAAE,SAAS,EAAC;AAC3C;AACA,YAAY,IAAI,kBAAkB,IAAI,IAAI;AAC1C,gBAAgB,IAAI,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC,EAAE,CAAC,EAAC;AAC1E;AACA,gBAAgB,IAAI,CAAC,0BAA0B,CAAC,kBAAkB,EAAE,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAC;AACvF,SAAS;AACT,KAAK;AACL;;AC7JA,MAAM,eAAe,cAAc,CAAC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AC3FD;AACA;AACA;AACA;AACA;AACA,MAAM,wBAAwB,cAAc,CAAC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;ACzHD,MAAM,sBAAsB,cAAc,CAAC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AC1CD,MAAM,eAAe,GAAG,CAAC,WAAW,GAAG,KAAK,EAAE,UAAU,GAAG,KAAK,EAAE,UAAU,GAAG,MAAM,gBAAgB,CAAC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,GAAG,WAAW,GAAG,oBAAoB,GAAG,4DAA4D,EAAE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,GAAG,UAAU,GAAG,SAAS,CAAC,UAAU,CAAC,GAAG,sBAAsB,EAAE;AACpE,CAAC,EAAC;AACF;AACA,MAAM,sBAAsB,cAAc,CAAC;AAC3C;AACA;AACA;AACA,EAAC;AACD;AACA,MAAM,oBAAoB,cAAc,CAAC;AACzC;AACA;AA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"}